import 'dart:collection';

final class Note extends LinkedListEntry<Note> {
  /// The unique identifier for the book.
  ///
  /// If no [id] is provided, it will be autogenerated based on the current
  /// microsecond timestamp.
  late int? id;
  late String? body;
  late String? dateCreated;
  late String? dateModified;

  Note({
    int? id,
    required this.body,
    String? dateCreated,
    String? dateModified,
  })  : id = id ?? DateTime.now().microsecondsSinceEpoch,
        dateCreated = dateCreated ?? DateTime.now().toIso8601String() {
    final DateTime dateTime = DateTime.fromMicrosecondsSinceEpoch(this.id!);
    if (dateModified == null) {
      this.dateModified = dateTime.toIso8601String();
    } else {
      this.dateModified = dateModified;
    }
  }

  Note.loading() : this(body: '...');
  Note.empty()
      : this(id: null, body: null, dateCreated: null, dateModified: null);

  bool get isLoading => body == '...';
  bool get isNull => body == null;

  @override
  String toString() {
    return 'id : $id\nbody : $body\ndateCreated : $dateCreated\ndateModified : $dateModified';
  }

  Future<void> prune() async {
    body = null;
    dateCreated = null;
    dateModified = null;
  }

  Future<void> reFetch(Note note) async {
    if (note.id != id) {
      throw ArgumentError('note.id and id is not the same in reFetch');
    }
    id = note.id;
    body = note.body;
    dateCreated = note.dateCreated;
    dateModified = note.dateModified;
  }

  Future<void> update({required body}) async {
    this.body = body;
    dateModified = DateTime.now().toIso8601String();
  }

  Future<Map<String, dynamic>> toMap() async {
    return {
      'id': id,
      'body': body,
      'date_created': dateCreated,
      'date_modified': dateModified,
    };
  }
}
